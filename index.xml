<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>naipia</title><link>https://naipia.github.io/</link><description>Recent content on naipia</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Mon, 23 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://naipia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>AtCoder水色到達時点の記録</title><link>https://naipia.github.io/blog/2020/03/rating-records/</link><pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate><guid>https://naipia.github.io/blog/2020/03/rating-records/</guid><description>競プロ2度目の復帰でAtCoder水色になった 去年の11月後半頃から習得も兼ねてGo言語で競プロに復帰し、AtCoder Beginner Contest 159で水色になりました（AtCoderID: naipia）。最初に競技プログラミング自体を始めたのは2016年なのですが、引退のプロなので水色になるまでに2回引退してしまいました。現段階では3度目の引退の予定はないのであくまでも１つのマイルストーンとして水色到達時までの記録を整理をしておきたいと思います。
記録 AtCoderでのレーティング推移 AtCoder Scoresの精進グラフ AtCoder Performancesのパフォーマンス推移 AtCoder Problems</description></item><item><title>2-SAT</title><link>https://naipia.github.io/procon/golib/two-sat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/two-sat/</guid><description>1type twosat struct { 2 scc *scc 3 ans []bool 4 n int 5} 6 7func newTwoSAT(n int) *twosat { 8 return &amp;amp;twosat{ 9 newStronglyConnectedComponents(2 * n), make([]bool, n), n, 10 } 11} 12 13func (ts *twosat) AddClause(i int, f bool, j int, g bool) { 14 p, q, a, b := 2*i, 2*j, 0, 0 15 if f { 16 a = 1 17 } 18 if g { 19 b = 1 20 } 21 ts.</description></item><item><title>Bellman-Ford</title><link>https://naipia.github.io/procon/golib/bellman-ford/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/bellman-ford/</guid><description>1type edge struct{ v, to, co int } 2 3func bellmanFord(es []edge, n, s, inf int) ([]int, bool) { 4 dist := make([]int, n) 5 for i := 0; i &amp;lt; n; i++ { 6 dist[i] = inf 7 } 8 dist[s] = 0 9 for i := 0; i &amp;lt; n-1; i++ { 10 for _, e := range es { 11 if dist[e.v] != inf &amp;amp;&amp;amp; dist[e.to] &amp;gt; dist[e.</description></item><item><title>Binary Indexed Tree</title><link>https://naipia.github.io/procon/golib/binary-indexed-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/binary-indexed-tree/</guid><description>func newBinaryIndexedTree(n int) *binaryIndexedTree func (t binaryIndexedTree) Sum(i int) int func (t binaryIndexedTree) RangeSum(l, r int) int func (t binaryIndexedTree) Add(i, x int) func (t binaryIndexedTree) LowerBound(x int) int 1type binaryIndexedTree []int 2 3func newBinaryIndexedTree(n int) *binaryIndexedTree { 4 bit := make(binaryIndexedTree, n+1) 5 return &amp;amp;bit 6} 7 8func (t binaryIndexedTree) Sum(i int) int { 9 s := 0 10 for i++; i &amp;gt; 0; i -= i &amp;amp; -i { 11 s += t[i] 12 } 13 return s 14} 15 16func (t binaryIndexedTree) RangeSum(l, r int) int { 17 return t.</description></item><item><title>Convolution</title><link>https://naipia.github.io/procon/golib/convolution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/convolution/</guid><description>1func convolutionMod(a, b []int, M int) []int { 2 n1, n2 := len(a), len(b) 3 n := n1 + n2 - 1 4 if n1 == 0 || n2 == 0 { 5 return []int{} 6 } 7 8 z := 1 &amp;lt;&amp;lt; ceilPow2(n) 9 aa, bb := make([]int, z), make([]int, z) 10 copy(aa, a) 11 copy(bb, b) 12 a, b = aa, bb 13 14 butterfly(a, M) 15 butterfly(b, M) 16 for i := 0; i &amp;lt; z; i++ { 17 a[i] = a[i] * b[i] % M 18 } 19 butterflyInv(a, M) 20 a = a[:n] 21 iz := invMod(z, M) 22 for i := 0; i &amp;lt; n; i++ { 23 a[i] = a[i] * iz % M 24 if a[i] &amp;lt; 0 { 25 a[i] += M 26 } 27 } 28 29 return a 30} 31 32func convolution(a, b []int) []int { 33 n1, n2 := len(a), len(b) 34 n := n1 + n2 - 1 35 if n1 == 0 || n2 == 0 { 36 return []int{} 37 } 38 39 MOD1 := 754974721 40 MOD2 := 167772161 41 MOD3 := 469762049 42 M2M3 := MOD2 * MOD3 43 M1M3 := MOD1 * MOD3 44 M1M2 := MOD1 * MOD2 45 M1M2M3 := MOD1 * MOD2 * MOD3 46 47 i1 := invMod(M2M3, MOD1) 48 i2 := invMod(M1M3, MOD2) 49 i3 := invMod(M1M2, MOD3) 50 51 c1 := convolutionMod(a, b, MOD1) 52 c2 := convolutionMod(a, b, MOD2) 53 c3 := convolutionMod(a, b, MOD3) 54 55 c := make([]int, n) 56 offset := []int{0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3} 57 58 for i := 0; i &amp;lt; n; i++ { 59 x := 0 60 x += c1[i] * i1 % MOD1 * M2M3 61 x += c2[i] * i2 % MOD2 * M1M3 62 x += c3[i] * i3 % MOD3 * M1M2 63 diff := c1[i] - x%MOD1 64 if diff &amp;lt; 0 { 65 diff += MOD1 66 } 67 x -= offset[diff%5] 68 c[i] = x 69 } 70 71 return c 72} 73 74func primitiveRoot(m int) int { 75 if m == 2 { 76 return 1 77 } 78 if m == 167772161 || m == 469762049 || m == 998244353 { 79 return 3 80 } 81 if m == 754974721 { 82 return 11 83 } 84 divs := make([]int, 20) 85 divs[0] = 2 86 cnt := 1 87 x := (m - 1) / 2 88 for x%2 == 0 { 89 x /= 2 90 } 91 for i := 3; i*i &amp;lt;= x; i += 2 { 92 if x%i == 0 { 93 divs[cnt] = i 94 cnt++ 95 for x%i == 0 { 96 x /= i 97 } 98 } 99 } 100 if x &amp;gt; 1 { 101 divs[cnt] = x 102 cnt++ 103 } 104 for g := 2; ; g++ { 105 ok := true 106 for i := 0; i &amp;lt; cnt; i++ { 107 if powMod(g, (m-1)/divs[i], m) == 1 { 108 ok = false 109 break 110 } 111 } 112 if ok { 113 return g 114 } 115 } 116} 117 118func powMod(a, n, M int) int { 119 if M == 1 { 120 return 0 121 } 122 r := 1 123 for n &amp;gt; 0 { 124 if n&amp;amp;1 == 1 { 125 r = r * a % M 126 } 127 a = a * a % M 128 n &amp;gt;&amp;gt;= 1 129 } 130 return r 131} 132 133func invMod(a, M int) int { 134 p, x, u := M, 1, 0 135 for p !</description></item><item><title>Dijkstra</title><link>https://naipia.github.io/procon/golib/dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/dijkstra/</guid><description>1type edge struct{ to, co int } 2type vert struct{ d, v int } 3type pqForDijkstra []vert 4 5func (pq pqForDijkstra) Len() int { return len(pq) } 6func (pq pqForDijkstra) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } 7func (pq pqForDijkstra) Less(i, j int) bool { return pq[i].d &amp;lt; pq[j].d } 8func (pq *pqForDijkstra) Push(x interface{}) { *pq = append(*pq, x.(vert)) } 9func (pq *pqForDijkstra) Pop() interface{} { 10 x := (*pq)[len(*pq)-1] 11 *pq = (*pq)[0 : len(*pq)-1] 12 return x 13} 14 15func dijkstra(es [][]edge, s, inf int) []int { 16 d := make([]int, len(es)) 17 for i := 0; i &amp;lt; len(es); i++ { 18 d[i] = inf 19 } 20 d[s] = 0 21 pq := &amp;amp;pqForDijkstra{vert{0, s}} 22 heap.</description></item><item><title>Floor Sum</title><link>https://naipia.github.io/procon/golib/floor-sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/floor-sum/</guid><description>1func floorSum(n, m, a, b int) int { 2 ans := 0 3 if a &amp;gt;= m { 4 ans += (n - 1) * n * (a / m) / 2 5 a %= m 6 } 7 if b &amp;gt;= m { 8 ans += n * (b / m) 9 b %= m 10 } 11 12 yma := (a*n + b) / m 13 if yma == 0 { 14 return ans 15 } 16 xma := yma*m - b 17 ans += (n - (xma+a-1)/a) * yma 18 ans += floorSum(yma, a, m, (a-xma%a)%a) 19 return ans 20} 21</description></item><item><title>Lazy Segment Tree</title><link>https://naipia.github.io/procon/golib/lazy-segment-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/lazy-segment-tree/</guid><description>func newLazySegmentTree(n int, e func() S, id func() F, f func(a, b S) S, g func(a S, x F) S, h func(a, x F) F,) *lazySegmentTree func (s *lazySegmentTree) Set(i int, a S) func (s *lazySegmentTree) Build() func (s *lazySegmentTree) Get(k int) S func (s *lazySegmentTree) Update(l, r int, x F) func (s *lazySegmentTree) Query(l, r int) S func (s *lazySegmentTree) MaxRight(l int, f func(v S) bool) int func (s *lazySegmentTree) MinLeft(r int, f func(v S) bool) int 1type S struct{} 2type F struct{} 3 4type lazySegmentTree struct { 5 d []S 6 lz []F 7 n int 8 sz int 9 lg int 10 e func() S 11 id func() F 12 f func(a, b S) S 13 g func(a S, x F) S 14 h func(a, x F) F 15} 16 17func newLazySegmentTree(n int, 18 e func() S, 19 id func() F, 20 f func(a, b S) S, 21 g func(a S, x F) S, 22 h func(a, x F) F, 23) *lazySegmentTree { 24 sz, lg := 1, 0 25 for sz &amp;lt; n { 26 sz &amp;lt;&amp;lt;= 1 27 lg++ 28 } 29 d := make([]S, 2*sz) 30 lz := make([]F, 2*sz) 31 for i := 0; i &amp;lt; 2*sz; i++ { 32 d[i] = e() 33 lz[i] = id() 34 } 35 s := lazySegmentTree{d, lz, n, sz, lg, e, id, f, g, h} 36 return &amp;amp;s 37} 38 39func (s *lazySegmentTree) Set(i int, a S) { 40 s.</description></item><item><title>LCP Array</title><link>https://naipia.github.io/procon/golib/longest-common-prefix-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/longest-common-prefix-array/</guid><description>1func newLongestCommonPrefixArray(s string, sa []int) []int { 2 n := len(s) 3 lcp := make([]int, n-1) 4 ra := make([]int, n) 5 for i := 0; i &amp;lt; n; i++ { 6 ra[sa[i]] = i 7 } 8 9 for i, h := 0, 0; i &amp;lt; n; i++ { 10 if ra[i] == 0 { 11 continue 12 } 13 if h &amp;gt; 0 { 14 h-- 15 } 16 for j := sa[ra[i]-1]; j+h &amp;lt; n &amp;amp;&amp;amp; i+h &amp;lt; n; h++ { 17 if s[j+h] !</description></item><item><title>Mod</title><link>https://naipia.github.io/procon/golib/mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/mod/</guid><description>1func powMod(a, n, M int) int { 2 r := 1 3 for n &amp;gt; 0 { 4 if n&amp;amp;1 == 1 { 5 r = r * a % M 6 } 7 a = a * a % M 8 n &amp;gt;&amp;gt;= 1 9 } 10 return r 11} 12 13func invMod(a, M int) int { 14 p, x, u := M, 1, 0 15 for p != 0 { 16 t := a / p 17 a, p = p, a-t*p 18 x, u = u, x-t*u 19 } 20 if x &amp;lt; 0 { 21 x += M 22 } 23 return x 24} 25</description></item><item><title>Segment Tree</title><link>https://naipia.github.io/procon/golib/segment-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/segment-tree/</guid><description>func newSegmentTree(n int, e func() S, f func(a, b S) S) *segmentTree func (s *segmentTree) Set(i int, a S) func (s *segmentTree) Build() func (s *segmentTree) Get(i int) S func (s *segmentTree) Update(i int, a S) func (s *segmentTree) Query(l, r int) S func (s *segmentTree) MaxRight(l int, f func(v S) bool) int func (s *segmentTree) MinLeft(r int, f func(v S) bool) int 1type S struct{} 2 3type segmentTree struct { 4 d []S 5 n int 6 sz int 7 e func() S 8 f func(a, b S) S 9} 10 11func newSegmentTree(n int, e func() S, f func(a, b S) S) *segmentTree { 12 sz := 1 13 for sz &amp;lt; n { 14 sz &amp;lt;&amp;lt;= 1 15 } 16 s := segmentTree{make([]S, 2*sz), n, sz, e, f} 17 for i := 0; i &amp;lt; 2*sz; i++ { 18 s.</description></item><item><title>Suffix Array</title><link>https://naipia.github.io/procon/golib/suffix-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/suffix-array/</guid><description>1func newSuffixArray(s string) []int { 2 s2 := make([]int, len(s)) 3 for i, v := range s { 4 s2[i] = int(v) 5 } 6 7 return sais(s2, 255) 8} 9 10func newSuffixArrayInts(s []int) []int { 11 n := len(s) 12 idx := make([]int, n) 13 for i := 0; i &amp;lt; n; i++ { 14 idx[i] = i 15 } 16 sort.Slice(idx, func(i, j int) bool { 17 return s[idx[i]] &amp;lt; s[idx[j]] 18 }) 19 20 s2 := make([]int, n) 21 u := 0 22 for i := 0; i &amp;lt; n; i++ { 23 if i !</description></item><item><title>Union-Find</title><link>https://naipia.github.io/procon/golib/union-find/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/union-find/</guid><description>func newUnionFind(n int) *unionFind func (uf unionFind) Find(x int) int func (uf unionFind) Unite(x, y int) bool func (uf unionFind) Unite(x, y int) bool 1type unionFind []int 2 3func newUnionFind(n int) *unionFind { 4 uf := make(unionFind, n) 5 for i := 0; i &amp;lt; n; i++ { 6 uf[i] = -1 7 } 8 return &amp;amp;uf 9} 10 11func (uf unionFind) Find(x int) int { 12 if uf[x] &amp;lt; 0 { 13 return x 14 } 15 uf[x] = uf.</description></item><item><title>Z Algorithm</title><link>https://naipia.github.io/procon/golib/z-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/z-algorithm/</guid><description>1func zalgorithm(s string) []int { 2 n := len(s) 3 z := make([]int, n) 4 z[0] = n 5 for i, j := 1, 0; i &amp;lt; n; { 6 for i+j &amp;lt; n &amp;amp;&amp;amp; s[j] == s[i+j] { 7 j++ 8 } 9 z[i] = j 10 if j == 0 { 11 i++ 12 continue 13 } 14 k := 1 15 for ; i+k &amp;lt; n &amp;amp;&amp;amp; k+z[k] &amp;lt; j; k++ { 16 z[i+k] = z[k] 17 } 18 i += k 19 j -= k 20 } 21 return z 22} 23</description></item><item><title>ビット全探索</title><link>https://naipia.github.io/procon/golib/bit-exhaustive-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/bit-exhaustive-search/</guid><description>1func bitExhaustiveSearch(n int, fn func(a []bool)) { 2 all := 1 &amp;lt;&amp;lt; uint(n) 3 a := make([]bool, n) 4 for i := 0; i &amp;lt; all; i++ { 5 for j := 0; j &amp;lt; n; j++ { 6 if i&amp;gt;&amp;gt;uint(j)&amp;amp;1 == 1 { 7 a[j] = true 8 } else { 9 a[j] = false 10 } 11 } 12 fn(a) 13 } 14} 15</description></item><item><title>ユークリッドの互除法</title><link>https://naipia.github.io/procon/golib/euclidean-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/euclidean-algorithm/</guid><description>1func gcd(m, n int) int { 2 for n != 0 { 3 m, n = n, m%n 4 } 5 return m 6} 7 拡張ユークリッドの互除法 1func extgcd(m, n int) (int, int, int) { 2 x, y := 1, 0 3 u, v := 0, 1 4 for n != 0 { 5 k := m / n 6 m, n = n, m-k*n 7 x, u = u, x-k*u 8 y, v = v, y-k*v 9 } 10 return m, x, y 11} 12</description></item><item><title>中国余剰定理</title><link>https://naipia.github.io/procon/golib/chinese-remainder-theorem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/chinese-remainder-theorem/</guid><description>1func crt(r []int, m []int) (int, int) { 2 r0, m0 := 0, 1 3 4 invGcd := func(a, p int) (int, int) { 5 x, u := 1, 0 6 for p != 0 { 7 t := a / p 8 a, p = p, a-t*p 9 x, u = u, x-t*u 10 } 11 return a, x 12 } 13 14 for i := 0; i &amp;lt; len(r); i++ { 15 r1, m1 := r[i], m[i] 16 if m0 &amp;lt; m1 { 17 r0, r1 = r1, r0 18 m0, m1 = m1, m0 19 } 20 21 if m0%m1 == 0 { 22 if r0%m1 !</description></item><item><title>二部グラフ最大マッチング</title><link>https://naipia.github.io/procon/golib/bipartite-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/bipartite-matching/</guid><description>1func bipartiteMatching(g [][]int) (int, []int) { 2 used := make([]int, len(g)) 3 match := make([]int, len(g)) 4 for i := 0; i &amp;lt; len(g); i++ { 5 match[i] = -1 6 } 7 cnt := 0 8 9 var fn func(v int) bool 10 fn = func(v int) bool { 11 if used[v] == cnt { 12 return false 13 } 14 used[v] = cnt 15 for _, to := range g[v] { 16 if match[to] == -1 || fn(match[to]) { 17 match[v], match[to] = to, v 18 return true 19 } 20 } 21 return false 22 } 23 24 res := 0 25 26 for i := 0; i &amp;lt; len(g); i++ { 27 cnt++ 28 if match[i] == -1 &amp;amp;&amp;amp; fn(i) { 29 res++ 30 } 31 } 32 33 return res, match 34} 35</description></item><item><title>強連結成分分解</title><link>https://naipia.github.io/procon/golib/strongly-connected-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/strongly-connected-components/</guid><description>1type scc struct { 2 g [][]int 3 rg [][]int 4} 5 6func newStronglyConnectedComponents(n int) *scc { 7 return &amp;amp;scc{make([][]int, n), make([][]int, n)} 8} 9 10func (s *scc) AddEdge(v, to int) { 11 s.g[v] = append(s.g[v], to) 12 s.rg[to] = append(s.rg[to], v) 13} 14 15func (s *scc) Scc() [][]int { 16 n := len(s.g) 17 vs := make([]int, 0, n) 18 vis := make([]bool, n) 19 cmp := make([]int, n) 20 21 var dfs func(v int) 22 dfs = func(v int) { 23 vis[v] = true 24 for _, to := range s.</description></item><item><title>最大流</title><link>https://naipia.github.io/procon/golib/max-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/max-flow/</guid><description>1type edge struct{ from, to, cap, flow int } 2type _edge struct{ to, cap, rev int } 3type maxFlow struct { 4 g [][]_edge 5 es [][2]int 6 lv []int 7 iter []int 8} 9 10func newMaxFlow(n int) *maxFlow { 11 return &amp;amp;maxFlow{make([][]_edge, n), [][2]int{}, make([]int, n), make([]int, n)} 12} 13 14func (mf *maxFlow) AddEdge(from, to, cap int) { 15 mf.es = append(mf.es, [2]int{from, len(mf.g[from])}) 16 mf.g[from] = append(mf.g[from], _edge{to, cap, len(mf.</description></item><item><title>最小全域木</title><link>https://naipia.github.io/procon/golib/kruskal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/kruskal/</guid><description>1type unionFind []int 2 3func newUnionFind(n int) *unionFind { 4 uf := make(unionFind, n) 5 for i := 0; i &amp;lt; n; i++ { 6 uf[i] = -1 7 } 8 return &amp;amp;uf 9} 10 11func (uf unionFind) Find(x int) int { 12 if uf[x] &amp;lt; 0 { 13 return x 14 } 15 uf[x] = uf.Find(uf[x]) 16 return uf[x] 17} 18 19func (uf unionFind) Unite(x, y int) bool { 20 x, y = uf.</description></item><item><title>最小共通祖先</title><link>https://naipia.github.io/procon/golib/lowest-common-ancestor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/lowest-common-ancestor/</guid><description>1type lca struct { 2 dep []int 3 par [][]int 4} 5 6func newLowestCommonAncestor(g [][]int, r int) *lca { 7 n := len(g) 8 k := 1 9 for 1&amp;lt;&amp;lt;uint(k) &amp;lt; n { 10 k++ 11 } 12 lca := lca{make([]int, n), make([][]int, k)} 13 for i := 0; i &amp;lt; k; i++ { 14 lca.par[i] = make([]int, n) 15 } 16 var dfs func(v, p, d int) 17 dfs = func(v, p, d int) { 18 lca.</description></item><item><title>最小費用流</title><link>https://naipia.github.io/procon/golib/min-cost-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/min-cost-flow/</guid><description>1const inf = 1 &amp;lt;&amp;lt; 60 2 3type edge struct{ from, to, cap, flow, cost int } 4type _edge struct{ to, cap, rev, cost int } 5 6type minCostFlow struct { 7 n int 8 g [][]_edge 9 es [][2]int 10} 11 12func newMinCostFlow(n int) *minCostFlow { 13 return &amp;amp;minCostFlow{n, make([][]_edge, n), [][2]int{}} 14} 15 16func (mcf *minCostFlow) AddEdge(from, to, cap, cost int) { 17 mcf.es = append(mcf.es, [2]int{from, len(mcf.g[from])}) 18 mcf.</description></item><item><title>素因数分解</title><link>https://naipia.github.io/procon/golib/prime-factorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/prime-factorization/</guid><description>1func factorize(n int) map[int]int { 2 pf := map[int]int{} 3 for i := 2; i*i &amp;lt;= n; i++ { 4 for n%i == 0 { 5 pf[i]++ 6 n /= i 7 } 8 } 9 if n != 1 { 10 pf[n] = 1 11 } 12 return pf 13} 14 高速素因数分解 1type spft []int 2 3func newSmallestPrimeFactorTable(n int) *spft { 4 pt := make(spft, n+1) 5 for i := 0; i &amp;lt;= n; i++ { 6 pt[i] = i 7 } 8 for m := 2; m*m &amp;lt;= n; m++ { 9 if pt[m] &amp;lt; m { 10 continue 11 } 12 for i := m * m; i &amp;lt;= n; i += m { 13 if pt[i] == i { 14 pt[i] = m 15 } 16 } 17 } 18 return &amp;amp;pt 19} 20 21func (f spft) factorize(a int) map[int]int { 22 pf := map[int]int{} 23 for a !</description></item><item><title>素数テーブル</title><link>https://naipia.github.io/procon/golib/prime-table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/prime-table/</guid><description>1func newPrimeTable(n int) []bool { 2 pt := make([]bool, n+1) 3 for i := 2; i &amp;lt;= n; i++ { 4 pt[i] = true 5 } 6 for m := 2; m*m &amp;lt;= n; m++ { 7 if !pt[m] { 8 continue 9 } 10 for i := m * m; i &amp;lt;= n; i += m { 11 pt[i] = false 12 } 13 } 14 return pt 15} 16</description></item><item><title>組合せ</title><link>https://naipia.github.io/procon/golib/combination/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/combination/</guid><description>1type combination struct { 2 fact, ifact, inv []int 3 m int 4} 5 6func newCombination(n, M int) *combination { 7 fact := make([]int, n+1) 8 ifact := make([]int, n+1) 9 inv := make([]int, n+1) 10 11 fact[0], fact[1] = 1, 1 12 ifact[0], ifact[1] = 1, 1 13 inv[1] = 1 14 15 for i := 1; i &amp;lt; n; i++ { 16 fact[i+1] = fact[i] * (i + 1) % M 17 inv[i+1] = M - inv[M%(i+1)]*(M/(i+1))%M 18 ifact[i+1] = ifact[i] * inv[i+1] % M 19 } 20 21 return &amp;amp;combination{fact, ifact, inv, M} 22} 23 24func (c *combination) P(m, n int) int { 25 return c.</description></item><item><title>順列全探索</title><link>https://naipia.github.io/procon/golib/permutation-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/permutation-search/</guid><description>1func permutationSearch(n int, fn func(a []int)) { 2 a := make([]int, n) 3 for i := 0; i &amp;lt; n; i++ { 4 a[i] = i 5 } 6 swap := func(i, j int) { a[i], a[j] = a[j], a[i] } 7 8 fn(a) 9 for i := n - 2; i &amp;gt;= 0; i-- { 10 if a[i] &amp;gt; a[i+1] { 11 continue 12 } 13 for j := n - 1; j &amp;gt;= 0; j-- { 14 if a[i] &amp;gt; a[j] { 15 continue 16 } 17 swap(i, j) 18 for k := i + 1; k &amp;lt; (n+i+1)/2; k++ { 19 swap(k, n-(k-i)) 20 } 21 fn(a) 22 i = n - 1 23 break 24 } 25 } 26} 27</description></item></channel></rss>