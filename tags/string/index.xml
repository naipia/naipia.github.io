<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>string on naipia</title><link>https://naipia.github.io/tags/string/</link><description>Recent content in string on naipia</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="https://naipia.github.io/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>LCP Array</title><link>https://naipia.github.io/procon/golib/longest-common-prefix-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/longest-common-prefix-array/</guid><description>1func newLongestCommonPrefixArray(s string, sa []int) []int { 2 n := len(s) 3 lcp := make([]int, n-1) 4 ra := make([]int, n) 5 for i := 0; i &amp;lt; n; i++ { 6 ra[sa[i]] = i 7 } 8 9 for i, h := 0, 0; i &amp;lt; n; i++ { 10 if ra[i] == 0 { 11 continue 12 } 13 if h &amp;gt; 0 { 14 h-- 15 } 16 for j := sa[ra[i]-1]; j+h &amp;lt; n &amp;amp;&amp;amp; i+h &amp;lt; n; h++ { 17 if s[j+h] !</description></item><item><title>Suffix Array</title><link>https://naipia.github.io/procon/golib/suffix-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/suffix-array/</guid><description>1func newSuffixArray(s string) []int { 2 s2 := make([]int, len(s)) 3 for i, v := range s { 4 s2[i] = int(v) 5 } 6 7 return sais(s2, 255) 8} 9 10func newSuffixArrayInts(s []int) []int { 11 n := len(s) 12 idx := make([]int, n) 13 for i := 0; i &amp;lt; n; i++ { 14 idx[i] = i 15 } 16 sort.Slice(idx, func(i, j int) bool { 17 return s[idx[i]] &amp;lt; s[idx[j]] 18 }) 19 20 s2 := make([]int, n) 21 u := 0 22 for i := 0; i &amp;lt; n; i++ { 23 if i !</description></item><item><title>Z Algorithm</title><link>https://naipia.github.io/procon/golib/z-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/z-algorithm/</guid><description>1func zalgorithm(s string) []int { 2 n := len(s) 3 z := make([]int, n) 4 z[0] = n 5 for i, j := 1, 0; i &amp;lt; n; { 6 for i+j &amp;lt; n &amp;amp;&amp;amp; s[j] == s[i+j] { 7 j++ 8 } 9 z[i] = j 10 if j == 0 { 11 i++ 12 continue 13 } 14 k := 1 15 for ; i+k &amp;lt; n &amp;amp;&amp;amp; k+z[k] &amp;lt; j; k++ { 16 z[i+k] = z[k] 17 } 18 i += k 19 j -= k 20 } 21 return z 22} 23</description></item></channel></rss>