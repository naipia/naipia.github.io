<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>math on naipia</title><link>https://naipia.github.io/tags/math/</link><description>Recent content in math on naipia</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="https://naipia.github.io/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>Convolution</title><link>https://naipia.github.io/procon/golib/convolution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/convolution/</guid><description>1func convolutionMod(a, b []int, M int) []int { 2 n1, n2 := len(a), len(b) 3 n := n1 + n2 - 1 4 if n1 == 0 || n2 == 0 { 5 return []int{} 6 } 7 8 z := 1 &amp;lt;&amp;lt; ceilPow2(n) 9 aa, bb := make([]int, z), make([]int, z) 10 copy(aa, a) 11 copy(bb, b) 12 a, b = aa, bb 13 14 butterfly(a, M) 15 butterfly(b, M) 16 for i := 0; i &amp;lt; z; i++ { 17 a[i] = a[i] * b[i] % M 18 } 19 butterflyInv(a, M) 20 a = a[:n] 21 iz := invMod(z, M) 22 for i := 0; i &amp;lt; n; i++ { 23 a[i] = a[i] * iz % M 24 if a[i] &amp;lt; 0 { 25 a[i] += M 26 } 27 } 28 29 return a 30} 31 32func convolution(a, b []int) []int { 33 n1, n2 := len(a), len(b) 34 n := n1 + n2 - 1 35 if n1 == 0 || n2 == 0 { 36 return []int{} 37 } 38 39 MOD1 := 754974721 40 MOD2 := 167772161 41 MOD3 := 469762049 42 M2M3 := MOD2 * MOD3 43 M1M3 := MOD1 * MOD3 44 M1M2 := MOD1 * MOD2 45 M1M2M3 := MOD1 * MOD2 * MOD3 46 47 i1 := invMod(M2M3, MOD1) 48 i2 := invMod(M1M3, MOD2) 49 i3 := invMod(M1M2, MOD3) 50 51 c1 := convolutionMod(a, b, MOD1) 52 c2 := convolutionMod(a, b, MOD2) 53 c3 := convolutionMod(a, b, MOD3) 54 55 c := make([]int, n) 56 offset := []int{0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3} 57 58 for i := 0; i &amp;lt; n; i++ { 59 x := 0 60 x += c1[i] * i1 % MOD1 * M2M3 61 x += c2[i] * i2 % MOD2 * M1M3 62 x += c3[i] * i3 % MOD3 * M1M2 63 diff := c1[i] - x%MOD1 64 if diff &amp;lt; 0 { 65 diff += MOD1 66 } 67 x -= offset[diff%5] 68 c[i] = x 69 } 70 71 return c 72} 73 74func primitiveRoot(m int) int { 75 if m == 2 { 76 return 1 77 } 78 if m == 167772161 || m == 469762049 || m == 998244353 { 79 return 3 80 } 81 if m == 754974721 { 82 return 11 83 } 84 divs := make([]int, 20) 85 divs[0] = 2 86 cnt := 1 87 x := (m - 1) / 2 88 for x%2 == 0 { 89 x /= 2 90 } 91 for i := 3; i*i &amp;lt;= x; i += 2 { 92 if x%i == 0 { 93 divs[cnt] = i 94 cnt++ 95 for x%i == 0 { 96 x /= i 97 } 98 } 99 } 100 if x &amp;gt; 1 { 101 divs[cnt] = x 102 cnt++ 103 } 104 for g := 2; ; g++ { 105 ok := true 106 for i := 0; i &amp;lt; cnt; i++ { 107 if powMod(g, (m-1)/divs[i], m) == 1 { 108 ok = false 109 break 110 } 111 } 112 if ok { 113 return g 114 } 115 } 116} 117 118func powMod(a, n, M int) int { 119 if M == 1 { 120 return 0 121 } 122 r := 1 123 for n &amp;gt; 0 { 124 if n&amp;amp;1 == 1 { 125 r = r * a % M 126 } 127 a = a * a % M 128 n &amp;gt;&amp;gt;= 1 129 } 130 return r 131} 132 133func invMod(a, M int) int { 134 p, x, u := M, 1, 0 135 for p !</description></item><item><title>Floor Sum</title><link>https://naipia.github.io/procon/golib/floor-sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/floor-sum/</guid><description>1func floorSum(n, m, a, b int) int { 2 ans := 0 3 if a &amp;gt;= m { 4 ans += (n - 1) * n * (a / m) / 2 5 a %= m 6 } 7 if b &amp;gt;= m { 8 ans += n * (b / m) 9 b %= m 10 } 11 12 yma := (a*n + b) / m 13 if yma == 0 { 14 return ans 15 } 16 xma := yma*m - b 17 ans += (n - (xma+a-1)/a) * yma 18 ans += floorSum(yma, a, m, (a-xma%a)%a) 19 return ans 20} 21</description></item><item><title>Mod</title><link>https://naipia.github.io/procon/golib/mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/mod/</guid><description>1func powMod(a, n, M int) int { 2 r := 1 3 for n &amp;gt; 0 { 4 if n&amp;amp;1 == 1 { 5 r = r * a % M 6 } 7 a = a * a % M 8 n &amp;gt;&amp;gt;= 1 9 } 10 return r 11} 12 13func invMod(a, M int) int { 14 p, x, u := M, 1, 0 15 for p != 0 { 16 t := a / p 17 a, p = p, a-t*p 18 x, u = u, x-t*u 19 } 20 if x &amp;lt; 0 { 21 x += M 22 } 23 return x 24} 25</description></item><item><title>ユークリッドの互除法</title><link>https://naipia.github.io/procon/golib/euclidean-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/euclidean-algorithm/</guid><description>1func gcd(m, n int) int { 2 for n != 0 { 3 m, n = n, m%n 4 } 5 return m 6} 7 拡張ユークリッドの互除法 1func extgcd(m, n int) (int, int, int) { 2 x, y := 1, 0 3 u, v := 0, 1 4 for n != 0 { 5 k := m / n 6 m, n = n, m-k*n 7 x, u = u, x-k*u 8 y, v = v, y-k*v 9 } 10 return m, x, y 11} 12</description></item><item><title>中国余剰定理</title><link>https://naipia.github.io/procon/golib/chinese-remainder-theorem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/chinese-remainder-theorem/</guid><description>1func crt(r []int, m []int) (int, int) { 2 r0, m0 := 0, 1 3 4 invGcd := func(a, p int) (int, int) { 5 x, u := 1, 0 6 for p != 0 { 7 t := a / p 8 a, p = p, a-t*p 9 x, u = u, x-t*u 10 } 11 return a, x 12 } 13 14 for i := 0; i &amp;lt; len(r); i++ { 15 r1, m1 := r[i], m[i] 16 if m0 &amp;lt; m1 { 17 r0, r1 = r1, r0 18 m0, m1 = m1, m0 19 } 20 21 if m0%m1 == 0 { 22 if r0%m1 !</description></item><item><title>素因数分解</title><link>https://naipia.github.io/procon/golib/prime-factorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/prime-factorization/</guid><description>1func factorize(n int) map[int]int { 2 pf := map[int]int{} 3 for i := 2; i*i &amp;lt;= n; i++ { 4 for n%i == 0 { 5 pf[i]++ 6 n /= i 7 } 8 } 9 if n != 1 { 10 pf[n] = 1 11 } 12 return pf 13} 14 高速素因数分解 1type spft []int 2 3func newSmallestPrimeFactorTable(n int) *spft { 4 pt := make(spft, n+1) 5 for i := 0; i &amp;lt;= n; i++ { 6 pt[i] = i 7 } 8 for m := 2; m*m &amp;lt;= n; m++ { 9 if pt[m] &amp;lt; m { 10 continue 11 } 12 for i := m * m; i &amp;lt;= n; i += m { 13 if pt[i] == i { 14 pt[i] = m 15 } 16 } 17 } 18 return &amp;amp;pt 19} 20 21func (f spft) factorize(a int) map[int]int { 22 pf := map[int]int{} 23 for a !</description></item><item><title>素数テーブル</title><link>https://naipia.github.io/procon/golib/prime-table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/prime-table/</guid><description>1func newPrimeTable(n int) []bool { 2 pt := make([]bool, n+1) 3 for i := 2; i &amp;lt;= n; i++ { 4 pt[i] = true 5 } 6 for m := 2; m*m &amp;lt;= n; m++ { 7 if !pt[m] { 8 continue 9 } 10 for i := m * m; i &amp;lt;= n; i += m { 11 pt[i] = false 12 } 13 } 14 return pt 15} 16</description></item><item><title>組合せ</title><link>https://naipia.github.io/procon/golib/combination/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/combination/</guid><description>1type combination struct { 2 fact, ifact, inv []int 3 m int 4} 5 6func newCombination(n, M int) *combination { 7 fact := make([]int, n+1) 8 ifact := make([]int, n+1) 9 inv := make([]int, n+1) 10 11 fact[0], fact[1] = 1, 1 12 ifact[0], ifact[1] = 1, 1 13 inv[1] = 1 14 15 for i := 1; i &amp;lt; n; i++ { 16 fact[i+1] = fact[i] * (i + 1) % M 17 inv[i+1] = M - inv[M%(i+1)]*(M/(i+1))%M 18 ifact[i+1] = ifact[i] * inv[i+1] % M 19 } 20 21 return &amp;amp;combination{fact, ifact, inv, M} 22} 23 24func (c *combination) P(m, n int) int { 25 return c.</description></item></channel></rss>