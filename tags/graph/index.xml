<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>graph on naipia</title><link>https://naipia.github.io/tags/graph/</link><description>Recent content in graph on naipia</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="https://naipia.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>2-SAT</title><link>https://naipia.github.io/procon/golib/two-sat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/two-sat/</guid><description>1type twosat struct { 2 scc *scc 3 ans []bool 4 n int 5} 6 7func newTwoSAT(n int) *twosat { 8 return &amp;amp;twosat{ 9 newStronglyConnectedComponents(2 * n), make([]bool, n), n, 10 } 11} 12 13func (ts *twosat) AddClause(i int, f bool, j int, g bool) { 14 p, q, a, b := 2*i, 2*j, 0, 0 15 if f { 16 a = 1 17 } 18 if g { 19 b = 1 20 } 21 ts.</description></item><item><title>Bellman-Ford</title><link>https://naipia.github.io/procon/golib/bellman-ford/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/bellman-ford/</guid><description>1type edge struct{ v, to, co int } 2 3func bellmanFord(es []edge, n, s, inf int) ([]int, bool) { 4 dist := make([]int, n) 5 for i := 0; i &amp;lt; n; i++ { 6 dist[i] = inf 7 } 8 dist[s] = 0 9 for i := 0; i &amp;lt; n-1; i++ { 10 for _, e := range es { 11 if dist[e.v] != inf &amp;amp;&amp;amp; dist[e.to] &amp;gt; dist[e.</description></item><item><title>Dijkstra</title><link>https://naipia.github.io/procon/golib/dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/dijkstra/</guid><description>1type edge struct{ to, co int } 2type vert struct{ d, v int } 3type pqForDijkstra []vert 4 5func (pq pqForDijkstra) Len() int { return len(pq) } 6func (pq pqForDijkstra) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } 7func (pq pqForDijkstra) Less(i, j int) bool { return pq[i].d &amp;lt; pq[j].d } 8func (pq *pqForDijkstra) Push(x interface{}) { *pq = append(*pq, x.(vert)) } 9func (pq *pqForDijkstra) Pop() interface{} { 10 x := (*pq)[len(*pq)-1] 11 *pq = (*pq)[0 : len(*pq)-1] 12 return x 13} 14 15func dijkstra(es [][]edge, s, inf int) []int { 16 d := make([]int, len(es)) 17 for i := 0; i &amp;lt; len(es); i++ { 18 d[i] = inf 19 } 20 d[s] = 0 21 pq := &amp;amp;pqForDijkstra{vert{0, s}} 22 heap.</description></item><item><title>二部グラフ最大マッチング</title><link>https://naipia.github.io/procon/golib/bipartite-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/bipartite-matching/</guid><description>1func bipartiteMatching(g [][]int) (int, []int) { 2 used := make([]int, len(g)) 3 match := make([]int, len(g)) 4 for i := 0; i &amp;lt; len(g); i++ { 5 match[i] = -1 6 } 7 cnt := 0 8 9 var fn func(v int) bool 10 fn = func(v int) bool { 11 if used[v] == cnt { 12 return false 13 } 14 used[v] = cnt 15 for _, to := range g[v] { 16 if match[to] == -1 || fn(match[to]) { 17 match[v], match[to] = to, v 18 return true 19 } 20 } 21 return false 22 } 23 24 res := 0 25 26 for i := 0; i &amp;lt; len(g); i++ { 27 cnt++ 28 if match[i] == -1 &amp;amp;&amp;amp; fn(i) { 29 res++ 30 } 31 } 32 33 return res, match 34} 35</description></item><item><title>強連結成分分解</title><link>https://naipia.github.io/procon/golib/strongly-connected-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/strongly-connected-components/</guid><description>1type scc struct { 2 g [][]int 3 rg [][]int 4} 5 6func newStronglyConnectedComponents(n int) *scc { 7 return &amp;amp;scc{make([][]int, n), make([][]int, n)} 8} 9 10func (s *scc) AddEdge(v, to int) { 11 s.g[v] = append(s.g[v], to) 12 s.rg[to] = append(s.rg[to], v) 13} 14 15func (s *scc) Scc() [][]int { 16 n := len(s.g) 17 vs := make([]int, 0, n) 18 vis := make([]bool, n) 19 cmp := make([]int, n) 20 21 var dfs func(v int) 22 dfs = func(v int) { 23 vis[v] = true 24 for _, to := range s.</description></item><item><title>最大流</title><link>https://naipia.github.io/procon/golib/max-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/max-flow/</guid><description>1type edge struct{ from, to, cap, flow int } 2type _edge struct{ to, cap, rev int } 3type maxFlow struct { 4 g [][]_edge 5 es [][2]int 6 lv []int 7 iter []int 8} 9 10func newMaxFlow(n int) *maxFlow { 11 return &amp;amp;maxFlow{make([][]_edge, n), [][2]int{}, make([]int, n), make([]int, n)} 12} 13 14func (mf *maxFlow) AddEdge(from, to, cap int) { 15 mf.es = append(mf.es, [2]int{from, len(mf.g[from])}) 16 mf.g[from] = append(mf.g[from], _edge{to, cap, len(mf.</description></item><item><title>最小全域木</title><link>https://naipia.github.io/procon/golib/kruskal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/kruskal/</guid><description>1type unionFind []int 2 3func newUnionFind(n int) *unionFind { 4 uf := make(unionFind, n) 5 for i := 0; i &amp;lt; n; i++ { 6 uf[i] = -1 7 } 8 return &amp;amp;uf 9} 10 11func (uf unionFind) Find(x int) int { 12 if uf[x] &amp;lt; 0 { 13 return x 14 } 15 uf[x] = uf.Find(uf[x]) 16 return uf[x] 17} 18 19func (uf unionFind) Unite(x, y int) bool { 20 x, y = uf.</description></item><item><title>最小共通祖先</title><link>https://naipia.github.io/procon/golib/lowest-common-ancestor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/lowest-common-ancestor/</guid><description>1type lca struct { 2 dep []int 3 par [][]int 4} 5 6func newLowestCommonAncestor(g [][]int, r int) *lca { 7 n := len(g) 8 k := 1 9 for 1&amp;lt;&amp;lt;uint(k) &amp;lt; n { 10 k++ 11 } 12 lca := lca{make([]int, n), make([][]int, k)} 13 for i := 0; i &amp;lt; k; i++ { 14 lca.par[i] = make([]int, n) 15 } 16 var dfs func(v, p, d int) 17 dfs = func(v, p, d int) { 18 lca.</description></item><item><title>最小費用流</title><link>https://naipia.github.io/procon/golib/min-cost-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon/golib/min-cost-flow/</guid><description>1const inf = 1 &amp;lt;&amp;lt; 60 2 3type edge struct{ from, to, cap, flow, cost int } 4type _edge struct{ to, cap, rev, cost int } 5 6type minCostFlow struct { 7 n int 8 g [][]_edge 9 es [][2]int 10} 11 12func newMinCostFlow(n int) *minCostFlow { 13 return &amp;amp;minCostFlow{n, make([][]_edge, n), [][2]int{}} 14} 15 16func (mcf *minCostFlow) AddEdge(from, to, cap, cost int) { 17 mcf.es = append(mcf.es, [2]int{from, len(mcf.g[from])}) 18 mcf.</description></item></channel></rss>