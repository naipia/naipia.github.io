<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>data structure on naipia</title><link>https://naipia.github.io/tags/data-structure/</link><description>Recent content in data structure on naipia</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="https://naipia.github.io/tags/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Indexed Tree</title><link>https://naipia.github.io/procon-lib-go/binary-indexed-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon-lib-go/binary-indexed-tree/</guid><description>func newBinaryIndexedTree(n int) *binaryIndexedTree func (t binaryIndexedTree) Sum(i int) int func (t binaryIndexedTree) RangeSum(l, r int) int func (t binaryIndexedTree) Add(i, x int) func (t binaryIndexedTree) LowerBound(x int) int 1type binaryIndexedTree []int 2 3func newBinaryIndexedTree(n int) *binaryIndexedTree { 4 bit := make(binaryIndexedTree, n+1) 5 return &amp;amp;bit 6} 7 8func (t binaryIndexedTree) Sum(i int) int { 9 s := 0 10 for i++; i &amp;gt; 0; i -= i &amp;amp; -i { 11 s += t[i] 12 } 13 return s 14} 15 16func (t binaryIndexedTree) RangeSum(l, r int) int { 17 return t.</description></item><item><title>Lazy Segment Tree</title><link>https://naipia.github.io/procon-lib-go/lazy-segment-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon-lib-go/lazy-segment-tree/</guid><description>func newLazySegmentTree(n int, e func() S, id func() F, f func(a, b S) S, g func(a S, x F) S, h func(a, x F) F,) *lazySegmentTree func (s *lazySegmentTree) Set(i int, a S) func (s *lazySegmentTree) Build() func (s *lazySegmentTree) Get(k int) S func (s *lazySegmentTree) Update(l, r int, x F) func (s *lazySegmentTree) Query(l, r int) S func (s *lazySegmentTree) MaxRight(l int, f func(v S) bool) int func (s *lazySegmentTree) MinLeft(r int, f func(v S) bool) int 1type S struct{} 2type F struct{} 3 4type lazySegmentTree struct { 5 d []S 6 lz []F 7 n int 8 sz int 9 lg int 10 e func() S 11 id func() F 12 f func(a, b S) S 13 g func(a S, x F) S 14 h func(a, x F) F 15} 16 17func newLazySegmentTree(n int, 18 e func() S, 19 id func() F, 20 f func(a, b S) S, 21 g func(a S, x F) S, 22 h func(a, x F) F, 23) *lazySegmentTree { 24 sz, lg := 1, 0 25 for sz &amp;lt; n { 26 sz &amp;lt;&amp;lt;= 1 27 lg++ 28 } 29 d := make([]S, 2*sz) 30 lz := make([]F, 2*sz) 31 for i := 0; i &amp;lt; 2*sz; i++ { 32 d[i] = e() 33 lz[i] = id() 34 } 35 s := lazySegmentTree{d, lz, n, sz, lg, e, id, f, g, h} 36 return &amp;amp;s 37} 38 39func (s *lazySegmentTree) Set(i int, a S) { 40 s.</description></item><item><title>Segment Tree</title><link>https://naipia.github.io/procon-lib-go/segment-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon-lib-go/segment-tree/</guid><description>1type S struct{ v int } 2 3func op(a, b S) S { 4 if a.v &amp;gt; b.v { 5 return a 6 } 7 return b 8} 9 10func e() S { 11 return S{0} 12} 13 14type segTree struct { 15 d []S 16 n int 17 sz int 18 e func() S 19 f func(a, b S) S 20} 21 22func newSegTree(n int, e func() S, op func(a, b S) S) *segTree { 23 sz := 1 24 for sz &amp;lt; n { 25 sz &amp;lt;&amp;lt;= 1 26 } 27 s := segTree{make([]S, 2*sz), n, sz, e, op} 28 for i := 0; i &amp;lt; 2*sz; i++ { 29 s.</description></item><item><title>Union-Find</title><link>https://naipia.github.io/procon-lib-go/union-find/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://naipia.github.io/procon-lib-go/union-find/</guid><description>func newUnionFind(n int) *unionFind func (uf unionFind) Find(x int) int func (uf unionFind) Unite(x, y int) bool func (uf unionFind) Unite(x, y int) bool 1type unionFind []int 2 3func newUnionFind(n int) *unionFind { 4 uf := make(unionFind, n) 5 for i := 0; i &amp;lt; n; i++ { 6 uf[i] = -1 7 } 8 return &amp;amp;uf 9} 10 11func (uf unionFind) Find(x int) int { 12 if uf[x] &amp;lt; 0 { 13 return x 14 } 15 uf[x] = uf.</description></item></channel></rss>